{
  "3032318097410509007": [
    {
      "question": "Do I need to learn all design patterns before building real apps?",
      "answer": "No. It is usually more effective to build things first and then learn the patterns that match the problems you actually hit, like “too many if statements” or “hard‑to‑test global code”."
    },
    {
      "question": "When is a Singleton a bad idea in JavaScript?",
      "answer": "A Singleton becomes a problem when it silently turns into a global dumping ground: many unrelated things stored on one object, hidden dependencies, and tests that are hard to isolate because everything shares the same state."
    },
    {
      "question": "How can I practice these patterns without a big project?",
      "answer": "Take a small feature—like a notification system, a theme switcher, or a simple API client—and intentionally refactor it twice: once using a Module, once using Observer or Factory. This “double build” makes trade‑offs easier to see in a safe environment."
    },
    {
      "question": "Are design patterns different in React or Node.js?",
      "answer": "The names and ideas are the same, but the way they show up is slightly different. In React, components often act like observers of state changes, while in Node.js, modules and event emitters are typical places where Module and Observer patterns appear."
    },
    {
      "question": "How do design patterns help with interviews?",
      "answer": "Many JavaScript interview questions hide a pattern in plain sight: “swap algorithms at runtime” points to Strategy, “notify multiple listeners” to Observer, and “one shared config” to Singleton. Knowing patterns lets you explain your solution more clearly and confidently."
    }
  ],
  "3197912432376675878": [
    {
      "question": "Is destructuring just syntactic sugar, or does it change how my code runs?",
      "answer": "It is mostly syntactic sugar: under the hood, JavaScript is still accessing properties and array elements. The big benefit is readability and fewer chances for copy‑paste mistakes, not a radically different runtime behavior."
    },
    {
      "question": "Should I always destructure function parameters?",
      "answer": "Not always. Destructuring is great when the function uses several properties and you want the signature to show them clearly. If a function only touches one property, passing that property directly might be more readable."
    },
    {
      "question": "Is destructuring safe to use in older browsers?",
      "answer": "Destructuring is an ES6 feature. For modern frontend workflows (React, Angular, bundlers like Webpack/Vite), it is usually transpiled automatically for older browsers. If you are writing raw JS for very old environments, make sure your build setup or target browsers actually support it."
    },
    {
      "question": "How can I practice destructuring without breaking existing code?",
      "answer": "Pick a small, non‑critical file and refactor only local variables first. Replace repeated property access with a single destructuring statement, run your tests or refresh the page, and confirm everything still works. That gradual approach builds confidence quickly."
    },
    {
      "question": "Does destructuring have performance implications?",
      "answer": "In most cases, the performance difference is negligible. Destructuring may introduce a tiny overhead due to creating new bindings, but in real‑world applications, this is rarely a bottleneck. Focus on code clarity first; optimize only if you identify a real performance issue."
    }
  ],
  "3321904781342482745": [
    {
      "question": "Can I mix '??' and '||' in the same expression ?",
      "answer": "You can, but JavaScript has rules about operator precedence and you cannot directly combine them without parentheses. If you must mix them, always add parentheses to make the order explicit, for example: (value ?? defaultA) || fallbackB."
    },
    {
      "question": "What is the exact difference between 'value ?? fallback' and 'value || fallback' ?",
      "answer": "'value || fallback' returns 'fallback' for any falsy value (0, \"\", false, NaN, null, undefined). 'value ?? fallback' only returns 'fallback' when value is 'null' or 'undefined', preserving all other falsy values."
    },
    {
      "question": "Does '??' work in all browsers and Node versions ?",
      "answer": "'??' is part of modern JavaScript (ES2020). It is supported in current versions of major browsers and Node. For older environments, bundlers and transpilers (like Babel) can convert it to equivalent code, so check your build setup if you target legacy platforms."
    },
    {
      "question": "Is there any performance concern with using '??' often ?",
      "answer": "For typical frontend and backend JavaScript workloads, the performance difference compared with manual checks or '||' is negligible. Modern engines optimize these operators well; code clarity and correctness around 0, false, and \"\" are far more important in real projects."
    }
  ],
  "5355063644606321456": [
    {
      "question": "Are closures the same as 'keeping variables on the heap' ?",
      "answer": "Closures are a language‑level concept: the engine keeps variables alive as long as any inner function can still access them. How the engine stores them internally (stack, heap, environment records) is an implementation detail, but you can think of it as “the function carries its environment along."
    },
    {
      "question": "Can closures cause memory leaks ?",
      "answer": "Closures themselves do not automatically cause memory leaks. Problems appear if you keep long‑lived references (like event listeners on \"\"window\"\" or DOM nodes) that close over large objects you no longer need. Removing listeners or nulling out unused references lets the engine reclaim memory normally."
    },
    {
      "question": "How are closures used in React hooks ?",
      "answer": "Hooks like 'useState' and 'useEffect' rely heavily on closures. For example, the updater function from 'useState' closes over the component’s internal state slot. When you call it later, React uses that closure to know which state to update, even though the original render is long gone."
    },
    {
      "question": "Why does my closure sometimes show 'stale' state ?",
      "answer": "If you create a closure and then state changes elsewhere, the closure will still see whatever variables it actually closed over. In React, for example, creating a function outside of 'useEffect' or not including variables in the dependency array can cause the function to close over older values. The fix is usually to move where the function is defined or include the right dependencies so the closure is refreshed when needed."
    }
  ],
  "3120525541353958376": [
    {
      "question": "What is the default phase when I use 'addEventListener' ?",
      "answer": "By default, listeners fire in the bubbling phase. The third argument (options) defaults to { capture: false }, so you only see the event as it comes up from the target."
    },
    {
      "question": "Can the same event be handled in both capturing and bubbling phases ?",
      "answer": "Yes. The event travels through three stages: capturing → target → bubbling. If you attach listeners with capture: true and others with default bubbling, all of them can run (unless one of them stops propagation)."
    },
    {
      "question": "When should I prefer event delegation over individual listeners ?",
      "answer": "Use delegation when you have many similar child elements (list items, table rows, buttons in a grid) or when elements are added dynamically. Attach one listener to a stable ancestor and use event.target or closest() to figure out which child was interacted with."
    },
    {
      "question": "Does 'stopPropagation()' also prevent default browser behavior like link navigation ?",
      "answer": "No. 'stopPropagation()' only stops the event from moving to other listeners. To block the browser’s default action (like following a link or submitting a form), you must also call event.preventDefault() or return false in some older patterns."
    },
    {
      "question": "Is event capturing necessary in modern frameworks like React or Angular ?",
      "answer": "Most of the time, no—bubbling plus framework abstractions are enough. But understanding capturing helps when you work with raw DOM APIs, global listeners, analytics hooks, or when debugging why an outer handler sees an event before an inner one in complex layouts."
    }
  ],
  "5222663548685705143": [
    {
      "question": "When would I use both debounce AND throttle on the same event ?",
      "answer": "Resize is perfect—throttle gives smooth dragging feedback, debounce handles the final recalculation. I use this pattern on every responsive dashboard."
    },
    {
      "question": "Does debouncing hurt SEO or accessibility ?",
      "answer": "No, because screen readers fire input events normally, and search indexing doesn't care about client-side delays. The performance gains actually help accessibility."
    },
    {
      "question": "How do I debounce React components ?",
      "answer": "Use 'useCallback + useRef' for the timer, or libraries like 'lodash.debounce'. Cleanup in 'useEffect' return function."
    },
    {
      "question": "What's better for scroll—infinite scroll or 'load on demand' ?",
      "answer": "Throttled scroll position checking. Infinite scroll loads ahead predictively, 'load on demand' waits for exact bottom detection. Both work great throttled."
    },
    {
      "question": "Can these cause 'jumpy' animations ?",
      "answer": "Yes if delays are too long. For 60fps visuals, never exceed 16ms throttle. Debouncing is fine for non-visual calculations."
    },
    {
      "question": "Do modern browsers need these anymore ?",
      "answer": "Absolutely. requestAnimationFrame helps with rendering, but input/scroll events still fire at native rates (100-500/sec). Users on older hardware especially benefit."
    }
  ],
  "2218027210438624569": [
    {
      "question": "Is Redux Saga dead in 2026 ?",
      "answer": "No. RTK Query handles data fetching perfectly, but Saga still shines for orchestration (real-time, complex workflows, cancellation). They're complementary."
    },
    {
      "question": "How do you test Saga vs Thunk ?",
      "answer": "Thunk: Mock 'fetch' and test the returned promise.\n Saga: Mock effects ('call', 'put') and test the generator steps. Saga tests are more powerful but verbose."
    },
    {
      "question": "Can I use both in the same app ?",
      "answer": "Yes! Thunk for simple actions, Saga for complex. Redux doesn't care—both are just middleware."
    },
    {
      "question": "What's the RTK Query migration path ?",
      "answer": "Replace 'fetchOrders' thunks with 'useGetOrdersQuery'. Keep Saga for non‑API coordination (timers, race conditions, real-time)."
    },
    {
      "question": "Team pushback on Saga complexity ?",
      "answer": "Document your workflows visually first (flowcharts), then show the cancellation/retry features. Once they see 'cancel()' and 'retry()', the complexity justifies itself."
    },
    {
      "question": "Performance difference between Thunk/Saga ?",
      "answer": "Negligible. Both dispatch actions normally. Saga has slightly more overhead from generators, but it's microseconds. Architecture clarity matters more."
    }
  ],
  "738378818817929846": [
    {
      "question": "Are Observables only for Angular and RxJS ?",
      "answer": "No. Angular popularized them with RxJS, but the concept is library‑agnostic. You can build small observable patterns yourself or use them in React, Node, or pure JavaScript whenever streams of data make sense."
    },
    {
      "question": "Do Observables replace Promises completely ?",
      "answer": "Not really. Promises are still perfect for one‑off operations. Observables complement Promises by covering the “multiple values over time” use case. In many apps, you’ll use both side by side"
    },
    {
      "question": "Are Observables bad for performance ?",
      "answer": "They’re not inherently heavy. The cost comes from how many subscriptions and operators you create. When used properly (with clean unsubscriptions), they often improve performance by centralizing and controlling async flows instead of scattering event listeners everywhere."
    },
    {
      "question": "How do I avoid memory leaks with Observables ?",
      "answer": "Always unsubscribe when the consumer goes away. In frameworks: \n Angular: use takeUntil, AsyncPipe, or OnDestroy patterns. \n React: use cleanup functions inside useEffect. And be careful with long‑lived Observables that outlive their components."
    },
    {
      "question": "What’s the biggest mental shift when moving from Promises to Observables ?",
      "answer": "With Promises, you think “call a function, get a result later.” With Observables, you think “subscribe to a source, react to values over time.” It’s less like a function call and more like listening to a radio station."
    }
  ],
  "8734105623954555199": [
    {
      "question": "Is 'AsyncPipe' pure or impure ?",
      "answer": "It's pure magic. Updates automatically when the Observable emits, no manual subscription management. Use it everywhere possible."
    },
    {
      "question": "Can impure pipes crash my app performance ?",
      "answer": "Yes. One impure pipe with 1000 items = 1000 executions per change detection cycle. At 60fps, that's 60,000 executions/second. Monitor with Angular DevTools Profiler."
    },
    {
      "question": "Should I replace impure pipes with component methods ?",
      "answer": "Sometimes yes. Component methods run in the component context (easier debugging), but pipes are more declarative. Try both, profile both."
    },
    {
      "question": "OnPush + pure pipes = always fast ?",
      "answer": "NYes! OnPush only runs change detection when '@Inputs' change. Pure pipes skip 90% of work. This combo powers my largest production dashboards.o"
    }
  ]
}

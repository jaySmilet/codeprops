{
  "3032318097410509007": [
    {
      "question": "Do I need to learn all design patterns before building real apps?",
      "answer": "No. It is usually more effective to build things first and then learn the patterns that match the problems you actually hit, like “too many if statements” or “hard‑to‑test global code”."
    },
    {
      "question": "When is a Singleton a bad idea in JavaScript?",
      "answer": "A Singleton becomes a problem when it silently turns into a global dumping ground: many unrelated things stored on one object, hidden dependencies, and tests that are hard to isolate because everything shares the same state."
    },
    {
      "question": "How can I practice these patterns without a big project?",
      "answer": "Take a small feature—like a notification system, a theme switcher, or a simple API client—and intentionally refactor it twice: once using a Module, once using Observer or Factory. This “double build” makes trade‑offs easier to see in a safe environment."
    },
    {
      "question": "Are design patterns different in React or Node.js?",
      "answer": "The names and ideas are the same, but the way they show up is slightly different. In React, components often act like observers of state changes, while in Node.js, modules and event emitters are typical places where Module and Observer patterns appear."
    },
    {
      "question": "How do design patterns help with interviews?",
      "answer": "Many JavaScript interview questions hide a pattern in plain sight: “swap algorithms at runtime” points to Strategy, “notify multiple listeners” to Observer, and “one shared config” to Singleton. Knowing patterns lets you explain your solution more clearly and confidently."
    }
  ],
  "3197912432376675878": [
    {
      "question": "Is destructuring just syntactic sugar, or does it change how my code runs?",
      "answer": "It is mostly syntactic sugar: under the hood, JavaScript is still accessing properties and array elements. The big benefit is readability and fewer chances for copy‑paste mistakes, not a radically different runtime behavior."
    },
    {
      "question": "Should I always destructure function parameters?",
      "answer": "Not always. Destructuring is great when the function uses several properties and you want the signature to show them clearly. If a function only touches one property, passing that property directly might be more readable."
    },
    {
      "question": "Is destructuring safe to use in older browsers?",
      "answer": "Destructuring is an ES6 feature. For modern frontend workflows (React, Angular, bundlers like Webpack/Vite), it is usually transpiled automatically for older browsers. If you are writing raw JS for very old environments, make sure your build setup or target browsers actually support it."
    },
    {
      "question": "How can I practice destructuring without breaking existing code?",
      "answer": "Pick a small, non‑critical file and refactor only local variables first. Replace repeated property access with a single destructuring statement, run your tests or refresh the page, and confirm everything still works. That gradual approach builds confidence quickly."
    },
    {
      "question": "Does destructuring have performance implications?",
      "answer": "In most cases, the performance difference is negligible. Destructuring may introduce a tiny overhead due to creating new bindings, but in real‑world applications, this is rarely a bottleneck. Focus on code clarity first; optimize only if you identify a real performance issue."
    }
  ],
  "3321904781342482745": [
    {
      "question": "Can I mix '??' and '||' in the same expression ?",
      "answer": "You can, but JavaScript has rules about operator precedence and you cannot directly combine them without parentheses. If you must mix them, always add parentheses to make the order explicit, for example: (value ?? defaultA) || fallbackB."
    },
    {
      "question": "What is the exact difference between 'value ?? fallback' and 'value || fallback' ?",
      "answer": "'value || fallback' returns 'fallback' for any falsy value (0, \"\", false, NaN, null, undefined). 'value ?? fallback' only returns 'fallback' when value is 'null' or 'undefined', preserving all other falsy values."
    },
    {
      "question": "Does '??' work in all browsers and Node versions ?",
      "answer": "'??' is part of modern JavaScript (ES2020). It is supported in current versions of major browsers and Node. For older environments, bundlers and transpilers (like Babel) can convert it to equivalent code, so check your build setup if you target legacy platforms."
    },
    {
      "question": "Is there any performance concern with using '??' often ?",
      "answer": "For typical frontend and backend JavaScript workloads, the performance difference compared with manual checks or '||' is negligible. Modern engines optimize these operators well; code clarity and correctness around 0, false, and \"\" are far more important in real projects."
    }
  ],
  "5355063644606321456": [
    {
      "question": "Are closures the same as 'keeping variables on the heap' ?",
      "answer": "Closures are a language‑level concept: the engine keeps variables alive as long as any inner function can still access them. How the engine stores them internally (stack, heap, environment records) is an implementation detail, but you can think of it as “the function carries its environment along."
    },
    {
      "question": "Can closures cause memory leaks ?",
      "answer": "Closures themselves do not automatically cause memory leaks. Problems appear if you keep long‑lived references (like event listeners on \"\"window\"\" or DOM nodes) that close over large objects you no longer need. Removing listeners or nulling out unused references lets the engine reclaim memory normally."
    },
    {
      "question": "How are closures used in React hooks?",
      "answer": "Hooks like 'useState' and 'useEffect' rely heavily on closures. For example, the updater function from 'useState' closes over the component’s internal state slot. When you call it later, React uses that closure to know which state to update, even though the original render is long gone."
    },
    {
      "question": "Why does my closure sometimes show 'stale' state?",
      "answer": "If you create a closure and then state changes elsewhere, the closure will still see whatever variables it actually closed over. In React, for example, creating a function outside of 'useEffect' or not including variables in the dependency array can cause the function to close over older values. The fix is usually to move where the function is defined or include the right dependencies so the closure is refreshed when needed."
    }
  ]
}